/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
import { shapes, } from "powerbi-visuals-utils-svgutils";
import { inherit } from "./fontProperties";
import * as LabelUtils from "./labelUtils";
import * as Units from "./units";
import * as DataLabelRectPositioner from "./dataLabelRectPositioner";
import * as DataLabelPointPositioner from "./dataLabelPointPositioner";
export var LabelOrientation;
(function (LabelOrientation) {
    LabelOrientation[LabelOrientation["Vertical"] = 0] = "Vertical";
    LabelOrientation[LabelOrientation["Horizontal"] = 1] = "Horizontal";
})(LabelOrientation || (LabelOrientation = {}));
export class LabelArrangeGrid {
    constructor(labelDataPointGroups, viewport) {
        this.viewport = viewport;
        let maxLabelWidth = 0;
        let maxLabelHeight = 0;
        for (let labelDataPointsGroup of labelDataPointGroups) {
            for (let labelDataPoint of labelDataPointsGroup.labelDataPoints) {
                let dataLabelSize = labelDataPoint.labelSize;
                if (dataLabelSize.width > maxLabelWidth) {
                    maxLabelWidth = dataLabelSize.width;
                }
                if (dataLabelSize.height > maxLabelHeight) {
                    maxLabelHeight = dataLabelSize.height;
                }
            }
        }
        if (maxLabelWidth === 0) {
            maxLabelWidth = viewport.width;
        }
        if (maxLabelHeight === 0) {
            maxLabelHeight = viewport.height;
        }
        let cellSize = this.cellSize = { width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier, height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier };
        this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
        this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
        let grid = [];
        for (let i = 0, ilen = this.columnCount; i < ilen; i++) {
            grid[i] = [];
            for (let j = 0, jlen = this.rowCount; j < jlen; j++) {
                grid[i][j] = [];
            }
        }
        this.grid = grid;
    }
    /**
     * Add a rectangle to check collision against
     */
    add(rect) {
        let containingIndexRect = this.getContainingGridSubsection(rect);
        for (let x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
            for (let y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                this.grid[x][y].push(rect);
            }
        }
    }
    /**
     * Check whether the rect conflicts with the grid, either bleeding outside the
     * viewport or colliding with another rect added to the grid.
     */
    hasConflict(rect) {
        if (!this.isWithinGridViewport(rect)) {
            return true;
        }
        return this.hasCollision(rect);
    }
    /**
     * Attempt to position the given rect within the viewport.  Returns
     * the adjusted rectangle or null if the rectangle couldn't fit,
     * conflicts with the viewport, or is too far outside the viewport
     */
    tryPositionInViewport(rect) {
        // If it's too far outside the viewport, return null
        if (!this.isCloseToGridViewport(rect)) {
            return;
        }
        if (!this.isWithinGridViewport(rect)) {
            rect = this.tryMoveInsideViewport(rect);
        }
        if (rect && !this.hasCollision(rect)) {
            return rect;
        }
    }
    /**
     * Checks for a collision between the given rect and others in the grid.
     * Returns true if there is a collision.
     */
    hasCollision(rect) {
        let containingIndexRect = this.getContainingGridSubsection(rect);
        let grid = this.grid;
        let isIntersecting = shapes.Rect.isIntersecting;
        for (let x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
            for (let y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                for (let currentGridRect of grid[x][y]) {
                    if (isIntersecting(currentGridRect, rect)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Check to see if the given rect is inside the grid's viewport
     */
    isWithinGridViewport(rect) {
        return rect.left >= 0 &&
            rect.top >= 0 &&
            rect.left + rect.width <= this.viewport.width &&
            rect.top + rect.height <= this.viewport.height;
    }
    /**
     * Checks to see if the rect is close enough to the viewport to be moved inside.
     * "Close" here is determined by the distance between the edge of the viewport
     * and the closest edge of the rect; if that distance is less than the appropriate
     * dimension of the rect, we will reposition the rect.
     */
    isCloseToGridViewport(rect) {
        return rect.left + rect.width >= 0 - rect.width &&
            rect.top + rect.height >= -rect.height &&
            rect.left <= this.viewport.width + rect.width &&
            rect.top <= this.viewport.height + rect.height;
    }
    /**
     * Attempt to move the rect inside the grid's viewport.  Returns the resulting
     * rectangle with the same width/height adjusted to be inside the viewport or
     * null if it couldn't fit regardless.
     */
    tryMoveInsideViewport(rect) {
        let result = shapes.Rect.clone(rect);
        let viewport = this.viewport;
        // Return null if it's too big to fit regardless of positioning
        if (rect.width > viewport.width || rect.height > viewport.height) {
            return;
        }
        // Only one movement should be made in each direction, because we are only moving it inside enough for it to fit; there should be no overshooting.
        // Outside to the left
        if (rect.left < 0) {
            result.left = 0;
        }
        // Outside to the right
        else if (rect.left + rect.width > viewport.width) {
            result.left -= (rect.left + rect.width) - viewport.width;
        }
        // Outside above
        if (rect.top < 0) {
            result.top = 0;
        }
        // Outside below
        else if (rect.top + rect.height > viewport.height) {
            result.top -= (rect.top + rect.height) - viewport.height;
        }
        return result;
    }
    getContainingGridSubsection(rect) {
        return {
            xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
            xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
            yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
            yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
        };
    }
    static getCellCount(step, length, minCount, maxCount) {
        return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
    }
    static bound(value, min, max) {
        return Math.max(Math.min(value, max), min);
    }
}
/**
 * A multiplier applied to the largest width height to attempt to balance # of
 * labels in each cell and number of cells each label belongs to
 */
LabelArrangeGrid.cellSizeMultiplier = 2;
export class LabelLayout {
    constructor(options) {
        this.startingOffset = options.startingOffset;
        this.maximumOffset = options.maximumOffset;
        if (options.offsetIterationDelta != null) {
            this.offsetIterationDelta = options.offsetIterationDelta;
        }
        else {
            this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta;
        }
        if (options.horizontalPadding != null) {
            this.horizontalPadding = options.horizontalPadding;
        }
        else {
            this.horizontalPadding = LabelLayout.defaultHorizontalPadding;
        }
        if (options.verticalPadding != null) {
            this.verticalPadding = options.verticalPadding;
        }
        else {
            this.verticalPadding = LabelLayout.defaultVerticalPadding;
        }
        this.allowLeaderLines = !!options.allowLeaderLines;
        this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
    }
    layout(arg0, viewport) {
        let labelDataPointsGroups;
        if (this.isOldLabelDataPointGroups(arg0)) {
            labelDataPointsGroups = this.upgradeToNewLabelDataPointsGroups(arg0);
        }
        else {
            labelDataPointsGroups = arg0;
        }
        // Clear data labels for a new layout
        let labelDataPointsGroupsLayoutInfo = [];
        for (let labelDataPointsGroup of labelDataPointsGroups) {
            let labelDataPointsLayoutInfo = labelDataPointsGroup.labelDataPoints.map((labelDataPoint) => ({ labelDataPoint: labelDataPoint }));
            let labelGroupOrientation = labelDataPointsGroup.labelOrientation;
            for (let labelDataPointLayoutInfo of labelDataPointsLayoutInfo) {
                let labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
                labelDataPointLayoutInfo.hasBeenRendered = false;
                let textWidth = labelDataPoint.textSize.width;
                let textHeight = labelDataPoint.textSize.height;
                if (labelGroupOrientation === LabelOrientation.Vertical) {
                    textWidth = labelDataPoint.textSize.height;
                    textHeight = labelDataPoint.textSize.width;
                }
                if (labelDataPoint.hasBackground) {
                    labelDataPointLayoutInfo.labelSize = {
                        width: textWidth + 2 * LabelUtils.horizontalLabelBackgroundPadding,
                        height: textHeight + 2 * LabelUtils.verticalLabelBackgroundPadding,
                    };
                }
                else {
                    labelDataPointLayoutInfo.labelSize = {
                        width: textWidth,
                        height: textHeight,
                    };
                }
            }
            labelDataPointsGroupsLayoutInfo.push({
                labelDataPoints: labelDataPointsLayoutInfo,
                maxNumberOfLabels: labelDataPointsGroup.maxNumberOfLabels,
                labelOrientation: labelDataPointsGroup.labelOrientation,
            });
        }
        let resultingDataLabels = [];
        let grid = new LabelArrangeGrid(labelDataPointsGroupsLayoutInfo, viewport);
        const hasMultipleDataSeries = labelDataPointsGroupsLayoutInfo.length > 1;
        // Iterates on every series
        for (let labelDataPointsGroupLayoutInfo of labelDataPointsGroupsLayoutInfo) {
            let maxLabelsToRender = labelDataPointsGroupLayoutInfo.maxNumberOfLabels;
            // NOTE: we create a copy and modify the copy to keep track of preferred vs. non-preferred labels.
            let labelDataPointsLayoutInfo = [...labelDataPointsGroupLayoutInfo.labelDataPoints];
            let preferredLabels = [];
            let labelGroupOrientation = labelDataPointsGroupLayoutInfo.labelOrientation;
            // Exclude preferred labels
            for (let j = labelDataPointsLayoutInfo.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                let labelDataPoint = labelDataPointsLayoutInfo[j].labelDataPoint;
                if (labelDataPoint.isPreferred) {
                    preferredLabels.unshift(labelDataPointsLayoutInfo.splice(j, 1)[0]);
                    localMax--;
                }
            }
            // First iterate all the preferred labels
            if (preferredLabels.length > 0) {
                let positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender, labelGroupOrientation, hasMultipleDataSeries);
                maxLabelsToRender -= positionedLabels.length;
                resultingDataLabels = resultingDataLabels.concat(positionedLabels);
            }
            // While there are invisible not preferred labels and label distance is less than the max
            // allowed distance
            if (labelDataPointsLayoutInfo.length > 0) {
                let labels = this.positionDataLabels(labelDataPointsLayoutInfo, viewport, grid, maxLabelsToRender, labelGroupOrientation, hasMultipleDataSeries);
                resultingDataLabels = resultingDataLabels.concat(labels);
            }
            // TODO: Add reference lines if we want them
        }
        let filtedResultingDataLabels = resultingDataLabels.filter((d) => d.isVisible);
        return this.isOldLabelDataPointGroups(arg0) ? LabelUtils.downgradeToOldLabels(filtedResultingDataLabels) : filtedResultingDataLabels;
    }
    positionDataLabels(labelDataPointsLayoutInfo, viewport, grid, maxLabelsToRender, labelOrientation, hasMultipleDataSeries) {
        let resultingDataLabels = [];
        let offsetDelta = this.offsetIterationDelta;
        let currentOffset = this.startingOffset;
        let currentCenteredOffset = 0;
        let drawLeaderLinesOnIteration;
        let labelsRendered = 0;
        while (currentOffset <= this.maximumOffset && labelsRendered < maxLabelsToRender) {
            drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
            for (let labelDataPointLayoutInfo of labelDataPointsLayoutInfo) {
                let labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
                if (labelDataPointLayoutInfo.hasBeenRendered) {
                    continue;
                }
                let dataLabel;
                if (labelDataPoint.parentType === 1 /* Rectangle */) {
                    dataLabel = this.tryPositionForRectPositions(labelDataPointLayoutInfo, grid, currentOffset, currentCenteredOffset, labelOrientation, hasMultipleDataSeries);
                }
                else {
                    dataLabel = this.tryPositionForPointPositions(labelDataPointLayoutInfo, grid, currentOffset, drawLeaderLinesOnIteration, labelOrientation);
                }
                if (dataLabel) {
                    resultingDataLabels.push(dataLabel);
                    labelsRendered++;
                }
                if (!(labelsRendered < maxLabelsToRender)) {
                    break;
                }
            }
            currentOffset += offsetDelta;
            currentCenteredOffset += offsetDelta;
        }
        return resultingDataLabels;
    }
    tryPositionForRectPositions(labelDataPointLayoutInfo, grid, currentLabelOffset, currentCenteredLabelOffset, labelOrientation, hasMultipleDataSeries) {
        // Function declared and reused to reduce code duplication
        let labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
        let tryPosition = (position, adjustForViewport) => {
            const isInsidePosition = !!(position & 7 /* InsideAll */);
            const isOverflowPosition = !!(position & 224 /* OverflowAll */);
            const canFitWithinParent = DataLabelRectPositioner.canFitWithinParent(labelDataPointLayoutInfo, this.horizontalPadding, this.verticalPadding);
            if ((isInsidePosition || isOverflowPosition) && !canFitWithinParent) {
                // Inside and Overflow positioning require that at least one of width or height will fit
                return;
            }
            let resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelDataPointLayoutInfo, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
            if (resultingBoundingBox) {
                if (isInsidePosition && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelDataPoint, this.horizontalPadding, this.verticalPadding)) {
                    return;
                }
                if (isOverflowPosition && !DataLabelRectPositioner.isValidLabelOverflowing(resultingBoundingBox, labelDataPoint, hasMultipleDataSeries)) {
                    return;
                }
                grid.add(resultingBoundingBox);
                labelDataPointLayoutInfo.hasBeenRendered = true;
                return {
                    boundingBox: resultingBoundingBox,
                    text: labelDataPoint.text,
                    tooltip: labelDataPoint.tooltip,
                    isVisible: true,
                    identity: labelDataPoint.identity,
                    key: labelDataPoint.key,
                    fontProperties: inherit(labelDataPoint.fontProperties, { color: isInsidePosition ? labelDataPoint.insideFill : labelDataPoint.outsideFill }),
                    selected: false,
                    hasBackground: !!labelDataPoint.hasBackground,
                    labelOrientation: labelOrientation,
                    backgroundColor: labelDataPoint.backgroundColor,
                    backgroundTransparency: labelDataPoint.backgroundTransparency,
                };
            }
        };
        // Iterate over all positions that are valid for the data point
        for (let position of labelDataPoint.parentShape.validPositions) {
            let label = tryPosition(position, false /* adjustForViewport */);
            if (label)
                return label;
        }
        // If no position has been found and the option is enabled, try any outside positions while moving the label inside the viewport
        if (this.attemptToMoveLabelsIntoViewport) {
            for (let position of labelDataPoint.parentShape.validPositions) {
                let label = tryPosition(position, true /* adjustForViewport */);
                if (label)
                    return label;
            }
        }
        return null;
    }
    /**
     * Tests a particular position/offset combination for the given data label.
     * If the label can be placed, returns the resulting bounding box for the data
     * label.  If not, returns null.
     */
    static tryPositionRect(grid, position, labelDataPointLayoutInfo, offset, centerOffset, adjustForViewport) {
        let offsetForPosition = offset;
        const isCenterPosition = [
            1 /* InsideCenter */,
            32 /* OverflowInsideCenter */
        ].some((rectPosition) => rectPosition === position);
        if (isCenterPosition) {
            offsetForPosition = centerOffset;
        }
        let labelRect = DataLabelRectPositioner.getLabelRect(labelDataPointLayoutInfo, position, offsetForPosition);
        let labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
        if (!isCenterPosition || labelDataPoint.parentShape.orientation === 0 /* None */) {
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
            if (adjustForViewport) {
                return grid.tryPositionInViewport(labelRect);
            }
        }
        else {
            // If the position is centered, attempt to offset in both a positive and negative direction
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
            labelRect = DataLabelRectPositioner.getLabelRect(labelDataPointLayoutInfo, position, -offsetForPosition);
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
        }
        return null;
    }
    tryPositionForPointPositions(labelDataPointLayoutInfo, grid, currentLabelOffset, drawLeaderLines, labelOrientation) {
        // Function declared and reused to reduce code duplication
        let labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
        let tryPosition = (position, parentShape, adjustForViewport) => {
            let resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelDataPointLayoutInfo, currentLabelOffset, adjustForViewport);
            if (resultingBoundingBox) {
                grid.add(resultingBoundingBox);
                labelDataPointLayoutInfo.hasBeenRendered = true;
                return {
                    boundingBox: resultingBoundingBox,
                    text: labelDataPoint.text,
                    tooltip: labelDataPoint.tooltip,
                    isVisible: true,
                    isInsideParent: position === 256 /* Center */,
                    identity: labelDataPoint.identity,
                    key: labelDataPoint.key,
                    fontProperties: inherit(labelDataPoint.fontProperties, { color: position === 256 /* Center */ ? labelDataPoint.insideFill : labelDataPoint.outsideFill }),
                    selected: false,
                    leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                    hasBackground: !!labelDataPoint.hasBackground,
                    labelOrientation: labelOrientation,
                    backgroundColor: labelDataPoint.backgroundColor,
                    backgroundTransparency: labelDataPoint.backgroundTransparency,
                };
            }
        };
        // Iterate over all positions that are valid for the data point
        let parentShape = labelDataPoint.parentShape;
        let validPositions = parentShape.validPositions;
        for (let position of validPositions) {
            let label = tryPosition(position, parentShape, false /* adjustForViewport */);
            if (label)
                return label;
        }
        // Attempt to position at the most preferred position by simply moving it inside the viewport
        if (this.attemptToMoveLabelsIntoViewport && validPositions && validPositions.length) {
            let label = tryPosition(validPositions[0], parentShape, true /* adjustForViewport */);
            if (label)
                return label;
        }
        return null;
    }
    static tryPositionPoint(grid, position, labelDataPointLayoutInfo, offset, adjustForViewport) {
        let labelRect = DataLabelPointPositioner.getLabelRect(labelDataPointLayoutInfo.labelSize, labelDataPointLayoutInfo.labelDataPoint.parentShape, position, offset);
        if (!grid.hasConflict(labelRect)) {
            return labelRect;
        }
        if (adjustForViewport) {
            return grid.tryPositionInViewport(labelRect);
        }
        return null;
    }
    isOldLabelDataPoint(labelDataPoint) {
        let newLabelDataPoint = labelDataPoint;
        return !newLabelDataPoint.fontProperties;
    }
    isOldLabelDataPointGroups(labelDataPointGroups) {
        let newLabelDataPointGroups = labelDataPointGroups;
        if (newLabelDataPointGroups.length !== 0) {
            let labelDataPointGroup = newLabelDataPointGroups.filter((labelDataPointGroup) => {
                return labelDataPointGroup.labelDataPoints && labelDataPointGroup.labelDataPoints.length;
            })[0];
            if (labelDataPointGroup) {
                let labelDataPoint = labelDataPointGroup.labelDataPoints[0];
                return this.isOldLabelDataPoint(labelDataPoint);
            }
        }
        return false;
    }
    upgradeToNewLabelDataPointsGroups(labelDataPointsGroups) {
        let newLabelDataPointsGroups = [];
        for (let labelDataPointsGroup of labelDataPointsGroups) {
            let newLabelDataPointsGroup;
            newLabelDataPointsGroup = {
                labelOrientation: labelDataPointsGroup.labelOrientation,
                maxNumberOfLabels: labelDataPointsGroup.maxNumberOfLabels,
                labelDataPoints: []
            };
            labelDataPointsGroup.labelDataPoints.map((labelDataPoint) => {
                newLabelDataPointsGroup.labelDataPoints.push({
                    textSize: labelDataPoint.textSize,
                    isPreferred: labelDataPoint.isPreferred,
                    parentType: labelDataPoint.parentType,
                    parentShape: labelDataPoint.parentShape,
                    hasBackground: labelDataPoint.hasBackground,
                    text: labelDataPoint.text,
                    tooltip: labelDataPoint.tooltip,
                    insideFill: labelDataPoint.insideFill,
                    outsideFill: labelDataPoint.outsideFill,
                    identity: labelDataPoint.identity,
                    key: labelDataPoint.key,
                    fontProperties: {
                        size: labelDataPoint.fontSize
                            ? Units.FontSize.createFromPt(labelDataPoint.fontSize)
                            : undefined
                    },
                    secondRowText: labelDataPoint.secondRowText,
                    weight: labelDataPoint.weight,
                    backgroundColor: labelDataPoint.backgroundColor,
                    backgroundTransparency: labelDataPoint.backgroundTransparency,
                });
            });
            newLabelDataPointsGroups.push(newLabelDataPointsGroup);
        }
        return newLabelDataPointsGroups;
    }
}
// Default values
LabelLayout.defaultOffsetIterationDelta = 2;
LabelLayout.defaultHorizontalPadding = 2;
LabelLayout.defaultVerticalPadding = 2;
//# sourceMappingURL=labelLayout.js.map